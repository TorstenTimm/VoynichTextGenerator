//
//  Generator.swift
//  Voynich
//
//  Created by Torsten Timm on 16.11.14.
//  Copyright (c) 2014 Torsten Timm. All rights reserved.
//

import UIKit

protocol TextGenerator {
    var voynichText: [String] {
        get
    }
    
    init(linesToCreate: Int, lineLengthToCreate: Int, initialLines: [String], currierType: CURRIER)
}

enum ChooseMode: Int {
    case Random = 1, Localy = 2, Paragraph = 3
}

class AutoCopyTextGenerator: TextGenerator {
    
    let PARAGRAPH_STARTS_WITH_GALLOW_PROPABILITY = 94
    
    /// the text lines generated by generateText()
    var voynichText     = [String]()
    
    /// dictionary with remembered glyph groups
    var groupDictionary = Dictionary<GlyphGroup, Int>()
    
    /// list of alredy generated lines for choosing source glyphGroups from context
    var lineArrays      = [[GlyphGroup]]()
    
    /// list of already generated paragraph initial lines for choosing source glyphGroups
    var paragraphInitialLineArrays = [[GlyphGroup]]()
    
    /// the length of a line
    var lineLengthToCreate = 55
    
    /// the length of a page
    var pageLength         = 29
    
    var isShuffleEnabled   = false
    let maxRepeatCount     = 3
    
    var randomNumberGenerator: RandomNumberGenerator!
    
    var repeatedTokensI  = 0
    var repeatedTokensDy = 0
    var repeatedTokensOl = 0
    var repeatedTokensUnknown = 0
    
    var statTokens       = 0
    var statTokensI      = 0
    var statTokensDy     = 0
    var statTokensOl     = 0
    
    var IMinPercentage: Float = 0.19
    
    var startSamePosition_probability = 28
    var samePosition_probabilty       = 80
    
    /// currierType
    var currierType: CURRIER!
    
    let daiinGlyphGroup  = GlyphGroup(glyphGroup: "daiin",  generateType: GENERATE_TYPE.INITIAL)
    let olGlyphGroup     = GlyphGroup(glyphGroup: "ol",     generateType: GENERATE_TYPE.INITIAL)
    let chedyGlyphGroup  = GlyphGroup(glyphGroup: "chedy",  generateType: GENERATE_TYPE.INITIAL)
    let cheodyGlyphGroup = GlyphGroup(glyphGroup: "cheody", generateType: GENERATE_TYPE.INITIAL)
    
    /// init
    required init(linesToCreate: Int, lineLengthToCreate: Int, initialLines: [String], currierType: CURRIER) {
        
        self.currierType  = currierType
        self.lineLengthToCreate   = lineLengthToCreate
        
        if usePseudoRandomNumbers {
            var randomSeed: UInt32 = 90
            isShuffleEnabled       = true
            if initialLines[0] == CurrierAText {
                randomSeed         = CurrierASeed
                isShuffleEnabled   = false
            }
            if initialLines[0] == CurrierBText {
                randomSeed         = CurrierBSeed
                isShuffleEnabled   = false
            }
            let pseudoRandomGenerator = PseudoRandomNumberGenerator()
            pseudoRandomGenerator.seed(randomSeed)
            randomNumberGenerator         = pseudoRandomGenerator
            startSamePosition_probability = 28
            samePosition_probabilty       = 80
        } else {
            randomNumberGenerator         = RealRandomNumberGenerator()
            startSamePosition_probability = 23
            samePosition_probabilty       = 75
            isShuffleEnabled              = true
        }
        
        var wordCount = 0
        for line in initialLines {
            let textArray = line.componentsSeparatedByString(" ")
            wordCount += textArray.count
            for group in textArray {
                let glyphGroup = GlyphGroup(glyphGroup: group, generateType: GENERATE_TYPE.INITIAL)
                remember(glyphGroup)
            }
            let lineLength = line.characters.count
            if lineLength > lineLengthToCreate {
                let newInitialLine = trimInitialLine(textArray)
                voynichText.append(newInitialLine)
            } else {
                voynichText.append(line)
            }
        }
        
        if wordCount < 6 {
            remember(daiinGlyphGroup)
            remember(olGlyphGroup)
            if currierType == CURRIER.A {
                remember(cheodyGlyphGroup)
            } else {
                remember(chedyGlyphGroup)
            }
        }
        
        generateText(linesToCreate, initialLineCount: initialLines.count)
    }
    
    /// returns a string fitting into the available space
    func trimInitialLine(textArray: [String]) -> String {
        var newInitialLine = ""
        for group in textArray {
            let initialLineLength = newInitialLine.characters.count
            if initialLineLength < lineLengthToCreate {
                if initialLineLength == 0 {
                    newInitialLine = group
                } else {
                    newInitialLine = newInitialLine + " " + group
                }
            }
        }
        
        return newInitialLine
    }
    
    /// generate the text
    func generateText(linesToCreate: Int, initialLineCount: Int) {
        var countInParagraph = voynichText.count
        var countInPage = voynichText.count
        
        for var i = countInParagraph; i < linesToCreate; i++ {
            let isParagraphInitial = countInParagraph == 0
            var isParagraphFinal = false

            countInParagraph++
            countInPage++
            if countInPage == 29 || i == linesToCreate-1 {
                isParagraphFinal = true
                countInParagraph = 0
                countInPage = 0
            } else {
                if countInPage < 27 && countInParagraph > 3 && i < linesToCreate - 2 {
                    let rand = randomNumberGenerator.rand(100)
                    if rand < countInParagraph * 10 {
                        isParagraphFinal = true
                        countInParagraph = 0
                    }
                }
            }
            
            voynichText.append(generateLine(i, isParagraphInitial: isParagraphInitial, isParagraphFinal: isParagraphFinal, linesInPage: countInPage, initialLineCount: initialLineCount))
        }
        
        if debug {
            for line in voynichText {
                print(line)
            }
            // let percentageI : Float = Float(statTokensI) / Float(statTokens)
            // print("linesToCreate=\(linesToCreate) voynichText.count=\(voynichText.count) percentageI=\(percentageI)")
        }
    }
    
    /// generate a new line
    func generateLine(lineNumber: Int, isParagraphInitial: Bool, isParagraphFinal: Bool, linesInPage: Int, initialLineCount: Int) -> String {
        var isLineInitial = true
        var line = ""
        var maxLineLength = lineLengthToCreate
        
        // limit line length for last line in paragraph
        if isParagraphFinal {
           maxLineLength = randomNumberGenerator.rand(maxLineLength)
            if maxLineLength < 10 {
                maxLineLength = 15
            }
        }
        
        var tries = 0
        var glyphGroupArray = [GlyphGroup]()
        while line.characters.count + max(tries-3,0) < maxLineLength  {
            var availablePlaceInLine = maxLineLength - line.characters.count
            var sourceGroups = chooseSourceGroup(glyphGroupArray, isParagraphInitial: isParagraphInitial, isLineInitial: isLineInitial, linesInPage: linesInPage, initialLineCount: initialLineCount)
            
            var doit = false
            if isLineInitial {
                // first word in line should contain at least three tokens
                doit = sourceGroups[0].count > 2
            } else if sourceGroups[0].count > 4 {
                // limit the usage of source words with more then four tokens
                let rand = randomNumberGenerator.rand(4)
                if sourceGroups[0].count < 4+rand {
                    doit = true
                }
            } else {
                doit = true
            }
            if doit && sourceGroups[0].generateType == GENERATE_TYPE.COMBINE {
                if sourceGroups[1].generateType == GENERATE_TYPE.COMBINE {
                    doit = false
                } else {
                    let rand = randomNumberGenerator.rand(100)
                    if rand < 30 {
                        doit = false
                    }
                }
            }

            if doit {
                var newGroups = morphGroup(sourceGroups, isParagraphInitial: isParagraphInitial, isLineInitial: isLineInitial)
                
                // limit repeated words
                var doit = true
                let equalLastGroup = glyphGroupArray.count > 0 && (newGroups[0] == glyphGroupArray[glyphGroupArray.count-1])
                if equalLastGroup {
                    let rand = randomNumberGenerator.rand(100)
                    doit = rand < 50
                } else if isShuffleEnabled {
                    let newGroup = newGroups[0]
                    let isTypeI = newGroup.isTypeI()
                    let isTypeDy = newGroup.isTypeDy()
                    let isTypeOl = newGroup.isTypeOl()
                    if isTypeI && repeatedTokensI > maxRepeatCount {
                        doit = false
                    }
                    if isTypeDy && repeatedTokensDy > maxRepeatCount {
                        doit = false
                    }
                    if isTypeOl && repeatedTokensOl > maxRepeatCount {
                        doit = false
                    }
                    if !isTypeI && !isTypeDy && !isTypeOl && repeatedTokensUnknown > maxRepeatCount {
                        doit = false
                    }
                }
                
                if doit {
                    for var i = 0; i < newGroups.count; i++ {
                        var newGroup = newGroups[i]
                        
                        // at the end of a line add 'm' and if necessary trim the group
                        if availablePlaceInLine - newGroup.length <= 0 {
                            newGroup = tryToTrim(newGroup, availableLength: availablePlaceInLine)
                        }
                        
                        // add group
                        if availablePlaceInLine - newGroup.length >= 0 {
                            if i == 0 {
                                if isLineInitial {
                                    isLineInitial = false
                                } else {
                                    line += " "
                                    availablePlaceInLine--
                                }
                            } else {
                                line += " "
                                availablePlaceInLine--
                            }
                            glyphGroupArray.append(newGroup)
                            remember(newGroup)
                            line += newGroup.description
                            availablePlaceInLine -= newGroup.length
                            tries = 0
                        } else {
                            tries++
                        }
                    }
                }
            }
        }
        
        lineArrays.append(glyphGroupArray)
        if isParagraphInitial {
           paragraphInitialLineArrays.append(glyphGroupArray)
        }
        
        return line
    }
    
    /// generate shorter groups if the remaining place is limited
    func tryToTrim(glyphGroup: GlyphGroup, availableLength: Int) -> GlyphGroup {
        var length = glyphGroup.length
        
        var changed = false
        var newTokens = glyphGroup.copyElements()
        
        // change last token 'ol' --> 'om'
        let lastToken = newTokens[glyphGroup.count-1]
        let newToken = Glyph.replaceFinalGlyph(lastToken)
        if lastToken != newToken {
            length -= lastToken.characters.count
            length += newToken.characters.count
            newTokens[glyphGroup.count-1] = newToken
            changed = true
        }
        
        // try to substitute tokens
        for var i = 0; i < newTokens.count; i++ {
            if availableLength < length {
                let token = newTokens[i]
                let substitution = Glyph.searchShorterGlyph(token)
                if let subst = substitution {
                    newTokens[i] = subst.first
                    length -= token.characters.count
                    length += subst.first.characters.count
                    changed = true
                }
            }
        }

        // remove tokens
        while availableLength < length && newTokens.count > 2 {
            let firstToken = newTokens.removeAtIndex(0)
            length -= firstToken.characters.count
            changed = true
        }
        
        // return new group
        if changed {
            return GlyphGroup(tokens: newTokens, generateType: GENERATE_TYPE.SHORTEN)
        }
        
        return glyphGroup
    }
    
    /// pick a source group
    func chooseSourceGroup(actualLineArray: [GlyphGroup], isParagraphInitial: Bool, isLineInitial: Bool, linesInPage: Int, initialLineCount: Int) -> [GlyphGroup] {
        var rand = randomNumberGenerator.rand(100)
        
        // for the first line lineArrays is empty. therefore it is necessary to chose the source groups randomly.
        // for paragraphIni
        let mode = lineArrays.count < initialLineCount ? ChooseMode.Random : isParagraphInitial && rand < 70 && paragraphInitialLineArrays.count > 1 ? ChooseMode.Paragraph : ChooseMode.Localy
        
        var ret = [GlyphGroup]()
        switch mode {
        case .Random:
            // randomly
            // pick first source group
            rand = randomNumberGenerator.rand(groupDictionary.count)
            ret.append(Array(groupDictionary.keys)[rand])
            // pick second source group
            rand = randomNumberGenerator.rand(groupDictionary.count)
            ret.append(Array(groupDictionary.keys)[rand])
        case .Localy:
            rand = randomNumberGenerator.rand(100)
            
            // actual line contains less then four groups
            if actualLineArray.count <= 3 && rand <= 10 {
                switch actualLineArray.count {
                case 2:
                    // line contains 2 groups --> in 60 % use another line
                    let random = randomNumberGenerator.rand(100)
                    if random < 60 {
                        rand = 11
                    }
                case 3:
                    // line contains 3 groups --> in 40 % use another line
                    let random = randomNumberGenerator.rand(100)
                    if random < 40 {
                        rand = 11
                    }
                default:
                    // actual line contains none or only one group --> use another line
                    rand = 11
                }
            }
            switch rand {
            case 0...2:
                // pick the last generated group as source group
                ret.append(actualLineArray[actualLineArray.count-1])
                // pick second source group
                if actualLineArray.count-1 > 0 {
                    ret.append(actualLineArray[actualLineArray.count-2])
                } else {
                    ret.append(actualLineArray[actualLineArray.count-1])
                }
            case 3...10:
                // pick a random group within the same line as source group
                rand = randomNumberGenerator.rand(actualLineArray.count)
                ret.append(actualLineArray[rand])
                // pick second source group
                if rand > 0 {
                    ret.append(actualLineArray[rand-1])
                } else if rand < actualLineArray.count-1 {
                    ret.append(actualLineArray[rand+1])
                } else {
                    ret.append(actualLineArray[rand])
                }
            case 11...75:
                // pick one of the lines of the actual page as source line
                var line = lineArrays.count-1
                rand = randomNumberGenerator.rand(min(10, lineArrays.count))
                switch rand {
                case 5...10:
                    // pick one of the lines of the actual page as source line
                    line = lineArrays.count-(1+randomNumberGenerator.rand(max(2,linesInPage)-2))
                    if line < 0 {
                        line = lineArrays.count-1
                    }
                case 4:
                    // increase the chance for line 4 to be picked
                    line = lineArrays.count-4
                case 3:
                    // increase the chance for line 3 to be picked
                    line = lineArrays.count-3
                case 2:
                    // increase the chance for next to last line to be picked
                    line = lineArrays.count-2
                default:
                    // increase the chance for last line to be picked
                    line = lineArrays.count-1
                }
                
                // pick a source group
                let sourceLine = lineArrays[line]
                var pos = calcPos(actualLineArray, sourceLineArray: sourceLine)
                rand = randomNumberGenerator.rand(100)
                // check chance for picking a group in the same position
                if (rand <= startSamePosition_probability) || (pos > 2 && rand <= samePosition_probabilty) {
                    // check if pos is out of range
                    if pos < 0 || pos >= sourceLine.count {
                        if line == lineArrays.count-1 {
                            // last group of previous line
                            pos = sourceLine.count - 1
                        } else {
                            // out of range -> random
                            pos = randomNumberGenerator.rand(sourceLine.count)
                        }
                    }
                } else {
                    pos = randomNumberGenerator.rand(sourceLine.count)
                }
                
                // pick first source group
                ret.append(sourceLine[pos])
                // pick second source group
                if pos > 0 {
                    ret.append(sourceLine[pos-1])
                } else if pos < sourceLine.count-1 {
                    ret.append(sourceLine[pos+1])
                } else {
                    ret.append(sourceLine[pos])
                }
            default:
                // if less then 20 % of the generated groups containing the 'i' glyph use 'daiin' as source group
                // otherwise use a random group as source group
                let percentageI : Float = Float(statTokensI) / Float(statTokens)
                if percentageI < IMinPercentage {
                    ret.append(daiinGlyphGroup)
                } else {
                    // random
                    rand = randomNumberGenerator.rand(groupDictionary.count)
                    ret.append(Array(groupDictionary.keys)[rand])
                }
                rand = randomNumberGenerator.rand(groupDictionary.count)
                ret.append(Array(groupDictionary.keys)[rand])
            }
        case .Paragraph:
            // for paragraph initial lines use another paragraph initial line for picking the source group
            rand = randomNumberGenerator.rand(100)
            if !isLineInitial && rand <= 20 {
                rand = 21
            }
            
            // actual line contains less then four groups
            if actualLineArray.count <= 3 && rand <= 20 {
                switch actualLineArray.count {
                case 2:
                    // line contains 2 groups --> in 60 % use another line
                    let random = randomNumberGenerator.rand(100)
                    if random < 60 {
                        rand = 21
                    }
                case 3:
                    // line contains 3 groups --> in 40 % use another line
                    let random = randomNumberGenerator.rand(100)
                    if random < 40 {
                        rand = 21
                    }
                default:
                    // actual line contains none or only one group --> in 100 % use another line
                    rand = 21
                }
            }
            switch rand {
            case 0...5:
                // pick the last generated group as source group
                ret.append(actualLineArray[actualLineArray.count-1])
                // pick second source group
                if actualLineArray.count-1 > 0 {
                    ret.append(actualLineArray[actualLineArray.count-2])
                } else {
                    ret.append(actualLineArray[actualLineArray.count-1])
                }
            case 6...20:
                // pick a random group within the same line
                rand = randomNumberGenerator.rand(actualLineArray.count)
                // pick first soruce group
                ret.append(actualLineArray[rand])
                // pick second source group
                if rand > 0 {
                    ret.append(actualLineArray[rand-1])
                } else if rand < actualLineArray.count-1 {
                    ret.append(actualLineArray[rand+1])
                } else {
                    ret.append(actualLineArray[rand])
                }
            default:
                // use another paragraph initial line for picking the source group
                let rand = randomNumberGenerator.rand(paragraphInitialLineArrays.count)
                let sourceLine = paragraphInitialLineArrays[rand]
                
                var pos = 0
                if isLineInitial {
                    pos = randomNumberGenerator.rand(3)
                    if pos >= sourceLine.count {
                        pos = randomNumberGenerator.rand(sourceLine.count)
                    }
                } else {
                    pos = randomNumberGenerator.rand(sourceLine.count)
                }
                // pick first soruce group
                ret.append(sourceLine[pos])
                // pick second source group
                if pos > 0 {
                    ret.append(sourceLine[pos-1])
                } else if pos < sourceLine.count-1 {
                    ret.append(sourceLine[pos+1])
                } else {
                    ret.append(sourceLine[pos])
                }
            }
        }
        
        for var i = 0; i < ret.count; i++ {
            if ret[i].startsWithGallow() {
                var newTokens = ret[i].copyElements()
                newTokens.removeAtIndex(0)
                if newTokens.count > 0 {
                    ret[i] = GlyphGroup(tokens: newTokens, generateType: ret[i].generateType)
                }
            }
        }
        
        return ret
    }
    
    /// calc pos in sourceLineArray
    func calcPos(actualLineArray: [GlyphGroup], sourceLineArray: [GlyphGroup]) -> Int {
        var comparePos = 0
        for var i = 0; i < actualLineArray.count; i++ {
            let group = actualLineArray[i]
            comparePos = comparePos + group.length + 1
        }
        
        var pos = 0
        for var i = 0; i < sourceLineArray.count; i++ {
            let group = sourceLineArray[i]
            let length = group.length
            if comparePos > pos && comparePos < pos + length + 1 {
                return i
            }
            pos = pos + length + 1
            
        }
        
        return actualLineArray.count
    }
    
    /// if a `glyhGroup` is not to complex or invalid store it in the groupDictionary
    func remember(glyphGroup: GlyphGroup) {
        if glyphGroup.isValid() && glyphGroup.count < 8 && !glyphGroup.startsWithGallow() && !glyphGroup.endWithEndGlpyh() && glyphGroup.generateType != GENERATE_TYPE.COMBINE {
            groupDictionary.updateValue(1, forKey: glyphGroup)
        }
        
        statTokens++;
        if glyphGroup.isTypeI() {
            repeatedTokensDy    = 0
            repeatedTokensOl    = 0
            repeatedTokensUnknown = 0
            
            statTokensI++
            repeatedTokensI++
        } else if glyphGroup.isTypeDy() {
            repeatedTokensUnknown = 0
            repeatedTokensI     = 0
            repeatedTokensOl    = 0
            
            statTokensDy++
            repeatedTokensDy++
        } else if glyphGroup.isTypeOl() {
            repeatedTokensUnknown = 0
            repeatedTokensI     = 0
            repeatedTokensDy    = 0
            
            statTokensOl++
            repeatedTokensOl++
        } else {
            repeatedTokensI  = 0
            repeatedTokensDy = 0
            repeatedTokensOl = 0
            
            repeatedTokensUnknown++
        }
    }
    
    /// morph a `sourceGlyphGroup` into another glyph group by replacing, removing or adding tokens
    func morphGroup(sourceGlyphGroups: [GlyphGroup], isParagraphInitial: Bool = false, isLineInitial: Bool = false) -> [GlyphGroup] {
        let glyphGroup = sourceGlyphGroups[0]
        let length = glyphGroup.length
        var ret = [GlyphGroup]()
        var rand = isParagraphInitial && isLineInitial  ? 0 : randomNumberGenerator.rand(100)
        switch rand {
        case 65...81:
            // add & remove
            rand = randomNumberGenerator.rand(100)
            var addGlyph = true
            if length < 6 {
                addGlyph = length < 3 || rand < 94
            } else {
                addGlyph = !(length > 8 || rand < 94)
            }
            if addGlyph {
                // add
                ret.append(addRandomGlyph(glyphGroup, isParagraphInitial: isParagraphInitial, isLineInitial: isLineInitial))
            } else {
                // remove
                ret.append(tryToDeleteOneGlyph(glyphGroup))
            }
        case 82...99:
            // combine & split
            rand = randomNumberGenerator.rand(100)
            var combineGroups = true
            if length < 6 {
                // if the source group has less then 6 token prefer combineGlyphgroups() with 95 %
                combineGroups = length <= 2 || rand < 96
            } else {
                // if the source group has more then 8 token always use splitGlyphgroup() and with at least 6 token prefer splitGlyphgroup()
                combineGroups = rand < 4 && length <= 8
            }
            if combineGroups && glyphGroup.generateType != GENERATE_TYPE.COMBINE {
                // combine
                ret.append(combineGlyphgroups(sourceGlyphGroups))
            } else {
                // split
                let temp = splitGlyphgroup(glyphGroup)
                for t in temp {
                    ret.append(t)
                }
            }
        default:
            // replace an token with a similar one
            rand = randomNumberGenerator.rand(100)
            switch rand {
            case 0...30:
                // replace 1 x
                var temp = replaceRandomToken(glyphGroup, isParagraphInitial: isParagraphInitial)
                if glyphGroup == temp {
                    temp = replaceRandomToken(glyphGroup, isParagraphInitial: isParagraphInitial)
                }
                ret.append(temp)
            case 31...40:
                // replace 3 x
                let temp = replaceRandomToken(glyphGroup, isParagraphInitial: isParagraphInitial)
                var temp2 = replaceRandomToken(temp, isParagraphInitial: isParagraphInitial)
                if glyphGroup == temp2 {
                    temp2 = temp
                }
                var temp3 = replaceRandomToken(temp2, isParagraphInitial: isParagraphInitial)
                if glyphGroup == temp3 {
                    temp3 = temp2
                }
                ret.append(temp3)
            default:
                // replace 2 x
                let temp = replaceRandomToken(glyphGroup, isParagraphInitial: isParagraphInitial)
                var temp2 = replaceRandomToken(temp, isParagraphInitial: isParagraphInitial)
                if glyphGroup == temp2 {
                    temp2 = temp
                }
                ret.append(temp2)
            }
        }
        
        // handle gallows
        if isLineInitial {
            rand = randomNumberGenerator.rand(100)
            if isParagraphInitial && rand < PARAGRAPH_STARTS_WITH_GALLOW_PROPABILITY {
                ret[0] = addGallow(ret[0], isParagraphInitial: true, isLineInitial: true)
            } else {
                ret[0] = addLineInitalGlyph(ret[0])
            }
        } else {
            if ret[0].startsWithLineInitialGlyph() {
                let rand = randomNumberGenerator.rand(prefixGlyphs.count)
                    
                if rand < 3 && ret[0].count > 3 {
                    ret[0] = removeLineInitalGlyph(ret[0])
                }
            }
        }
        
        if !isParagraphInitial && Glyph.containsFirstLineGallow(ret[0].description) {
            rand = randomNumberGenerator.rand(100)
            if rand < PARAGRAPH_STARTS_WITH_GALLOW_PROPABILITY {
                ret[0] = replaceFirstLineGallows(ret[0])
            }
        } else if isParagraphInitial && ret[0].containsGallow() {
            ret[0] = replaceWithFirstLineGallows(ret[0])
        }
        
        let lastGroup = ret[ret.count - 1]
        if lastGroup.containsCombinableLigature() {
            rand = randomNumberGenerator.rand(100)
            if rand < 20 {
                let ligature = lastGroup.getCombinableLigature()!
                var groupToAdd = GlyphGroup(glyphGroup: ligature, generateType: GENERATE_TYPE.SPLIT)
                rand = randomNumberGenerator.rand(100)
                if rand < 50 {
                    groupToAdd = replaceRandomToken(groupToAdd, isParagraphInitial: isParagraphInitial)
                }
                ret.append(groupToAdd)
            }
        }
        
        return ret
    }
    
    /// delete an token
    func tryToDeleteOneGlyph(glyphGroup: GlyphGroup) -> GlyphGroup {
        let length = glyphGroup.count
        let pos = 0
        
        let glyph = glyphGroup[pos]
        if Glyph.isDeletable(glyph) {
            let previousGlyph = ""
            let nextGlyph = pos < length-1 ? glyphGroup[pos+1] : ""
            if Glyph.canFollowEachOther(glyphToAdd: previousGlyph, group2: nextGlyph) {
                var newTokens = glyphGroup.copyElements()
                newTokens.removeAtIndex(pos)

                // check if the group now starts with a gallow
                if pos == 0 && length > 2 {
                    let first = newTokens[0]
                    let second = newTokens[1]
                    if Glyph.isGallow(first) {
                        // kain --> dain
                        if second.hasPrefix("a") {
                            newTokens[0] = "d"
                        }
                        // kedy --> chedy
                        if second.hasPrefix("e") {
                            newTokens[0] = "ch"
                        }
                    }
                }
                
                return GlyphGroup(tokens: newTokens, generateType: glyphGroup.generateType)
            }
        }
        
        return glyphGroup
    }
    
    /// replace one token with a similar one
    func replaceRandomToken(glyphGroup: GlyphGroup, isParagraphInitial: Bool) -> GlyphGroup {
        // try several times to replace a token
        for var i = 0; i < 5; i++ {
            
            // chose token
            let pos = randomNumberGenerator.rand(glyphGroup.count)
            let subGroup = glyphGroup[pos]
            let possibleSubstitutions = Glyph.similarGlyph(subGroup)
            
            // replace token
            if let substitutions = possibleSubstitutions {
               
                var newTokens = glyphGroup.copyElements()
                let nextToken = newTokens.count > pos+1 ? newTokens[pos+1] : ""
                
                let substitute = choose(substitutions)
                var doit = true
                var removeNext = false
                // check if the substitute contains gallow glyphs
                if Glyph.containsGallow(substitute.elements) {
                    var rand = randomNumberGenerator.rand(100)
                    if Glyph.isGallow(nextToken) {
                        // allow cht --> ckh
                        removeNext = true
                    } else if glyphGroup.containsGallow()  && rand < 90 { // Glyph.containsGallow(glyphGroup.description)
                        // multiple gallows within a group are rare
                        doit = false
                    } else {
                        rand = randomNumberGenerator.rand(100)
                        if (isParagraphInitial && rand < 40) || (!isParagraphInitial && rand < 60) {
                            // limit the number of gallows
                            doit = false
                        }
                    }
                }
                if doit && isReplacable(newToken: substitute, glyphGroup: glyphGroup, pos: pos, removeNext: removeNext) {
                    newTokens.removeAtIndex(pos)
                    if removeNext {
                         newTokens.removeAtIndex(pos)
                    }
                    for var i = 0; i < substitute.count; i++ {
                        newTokens.insert(substitute[i], atIndex: pos+i)
                    }
                    var generateType = GENERATE_TYPE.REPLACE
                    if glyphGroup.generateType == GENERATE_TYPE.COMBINE {
                        generateType = glyphGroup.generateType
                    }
                    return GlyphGroup(tokens: newTokens, generateType: generateType)
                }
            }
        }
        
        return glyphGroup
    }
    
    /// randomly choose a similar token
    func choose(substitutions: [Substitution]) -> Substitution {
        //let index = RandomNumberGenerator.rand(substitutions.count)
        //return substitutions[index]
        let rand = randomNumberGenerator.rand(100)
        for substitute in substitutions {
            if substitute.probability > rand {
                return substitute
            }
        }
        
        // should not happen
        _ = substitutions[substitutions.count+1]
        
        return substitutions.last!
    }
    
    /// determine if the `newToken` at `pos`
    func isReplacable(newToken newToken: Substitution, glyphGroup: GlyphGroup, pos: Int, removeNext: Bool) -> Bool {
        
        let last = pos == 0 ? "" : glyphGroup[pos-1]
        let nextPos = removeNext ? pos+2 : pos+1
        let next = nextPos >= glyphGroup.count ? "" : glyphGroup[nextPos]
        let lastOk = Glyph.canFollowEachOther(group1: last, glyphToAdd: newToken.first)
        let nextOk = Glyph.canFollowEachOther(glyphToAdd: newToken.last, group2: next)
        
        // multiple instances off the same token within a group are rare
        if lastOk && nextOk && newToken.count == 1 && glyphGroup.contains(newToken.first) {
            let rand = randomNumberGenerator.rand(100)
            if rand < 50 {
                return false
            }
        }
        
        return lastOk && nextOk
    }

    // use two `sourceGroups` to generate a new GlyphGroup
    func combineGlyphgroups(sourceGroups: [GlyphGroup]) -> GlyphGroup {
        let glyphGroup1 = sourceGroups[0]
        let glyphGroup2 = sourceGroups[1]
        
        if glyphGroup1.count == 2 || (glyphGroup1.count == 1 && Glyph.isCombinableLigature(glyphGroup1.description)) {
            let rand = randomNumberGenerator.rand(100)
            if rand < 60 {
                let newGlyphGroup = selfCombine(glyphGroup: glyphGroup1)
                if newGlyphGroup != glyphGroup1 {
                    return newGlyphGroup
                }
            }
        }
        
        let newTokens2 = chooseSubgroups(glyphGroup: glyphGroup2)
        if newTokens2.count > 0 {
            let lastToken2 = newTokens2[newTokens2.count-1]
            var newTokens1 = glyphGroup1.copyElements()
            
            // check if it is necessary to remove the first token to prevent 'ol' in front of 'l'
            let tokensToRemove = combinableLigature[lastToken2]
            if let tokens = tokensToRemove {
                for token in tokens {
                    if newTokens1.count > 0 && token == newTokens1[0] {
                        newTokens1.removeAtIndex(0)
                    }
                }
            }
            
            // check length
            let newLength = newTokens1.count + newTokens2.count
            if newTokens1.count > 0 && newLength < 9 {
                // check if `newTokens2` is allowed in front of `newTokens1`
                if Glyph.canFollowEachOther(glyphToAdd: lastToken2, group2: newTokens1[0]) {
                    for var i = 0; i < newTokens2.count; i++ {
                        newTokens1.insert(newTokens2[i], atIndex: i)
                    }
                    let g = GlyphGroup(tokens: newTokens1, generateType: GENERATE_TYPE.COMBINE)
                    //println("combineGlyphgroups glyphGroup=\(glyphGroup) newToken=\(newToken) g=\(g) tokensToRemove=\(tokensToRemove)")
                    return g
                }
            }
        }
        
        if glyphGroup1.count <= 2 {
            return selfCombine(glyphGroup: glyphGroup1)
        }
        
        return glyphGroup1
    }
    
    /// generate self similar groups like "chochy" or "olol"
    func selfCombine(glyphGroup glyphGroup: GlyphGroup)  -> GlyphGroup {
        if glyphGroup.count > 0 {
            let firstToken = glyphGroup[0]
            let lastToken = glyphGroup[glyphGroup.count-1]
            if Glyph.canFollowEachOther(glyphToAdd: lastToken, group2: firstToken) {
                var newTokens = glyphGroup.copyElements()
                var newTokens1 = glyphGroup.copyElements()
                
                let lastToken = newTokens[newTokens.count-1]
                let inGroupReplacement = Glyph.replaceSelfIngroupGlyph(lastToken)
                let finalReplacement = Glyph.replaceSelfFinalGlyph(lastToken)
                
                if lastToken != finalReplacement {
                    let rand = randomNumberGenerator.rand(100)
                    if rand < 80 {
                        newTokens[newTokens.count-1] = finalReplacement
                    }
                }
                if lastToken != inGroupReplacement {
                    newTokens1[newTokens.count-1] = inGroupReplacement
                }
                
                if Glyph.canFollowEachOther(glyphToAdd: gallowGlyphs[0], group2: firstToken) && Glyph.canFollowEachOther(glyphToAdd: lastToken, group2: gallowGlyphs[0]) {
                    let rand = randomNumberGenerator.rand(100)
                    if rand < 30 {
                        let gallow = Glyph.randomGallow(firstLine: false, randomNumberGenerator: randomNumberGenerator)
                        newTokens.insert(gallow, atIndex: 0)
                    }
                }
                for var i = 0; i < newTokens1.count; i++ {
                    newTokens.insert(newTokens1[i], atIndex: i)
                }
                return GlyphGroup(tokens: newTokens, generateType: GENERATE_TYPE.COMBINE)
            }
        }
        
        return glyphGroup
    }
    
    /// choose a token
    func chooseSubgroup(glyphGroup glyphGroup: GlyphGroup) -> String {
        
        if glyphGroup.startsWithCombinableLigature() {
            for var i = 0; i < combinableLigature.count; i++ {
                let newToken = Array(combinableLigature.keys)[i]
                if glyphGroup.contains(newToken) {
                    return newToken
                }
            }
        }
        
        return ""
    }
    
    /// use this version with longer subgroups to generate rare glyphGroups
    func chooseSubgroups(glyphGroup glyphGroup: GlyphGroup) -> [String] {
        
        var rand = randomNumberGenerator.rand(100)
        switch rand {
        case 0...39:
            var ret = [String]()
            if glyphGroup.count > 1 {
                rand = randomNumberGenerator.rand(glyphGroup.count-1)+1
                for var i = 0; i < rand; i++ {
                    ret.append(glyphGroup[i])
                }
            }
            return ret
        case 40...59:
            var newTokens = glyphGroup.copyElements()
            newTokens.removeLast()
            return newTokens
        default:
            var ret = [String]()
            let subgroup = chooseSubgroup(glyphGroup: glyphGroup)
            if !subgroup.isEmpty {
                ret.append(subgroup)
                return ret
            } else {
                var newTokens = glyphGroup.copyElements()
                newTokens.removeLast()
                return newTokens
            }
        }
    }
    
    /// split `glyphGroup` into two groups
    func splitGlyphgroup(glyphGroup: GlyphGroup) -> [GlyphGroup] {
        var ret = [GlyphGroup]()
        if glyphGroup.startsWithCombinableLigature() && glyphGroup.count > 1 {
            //let length = glyphGroup.count
            for ligature in combinableLigature.keys {
                //let l1 = ligature.characters.count
                if glyphGroup.hasPrefix(ligature) {
                    let group1 = GlyphGroup(glyphGroup: ligature, generateType: GENERATE_TYPE.SPLIT)
                    ret.append(group1)
                    var newTokens = glyphGroup.copyElements()
                    newTokens.removeAtIndex(0)
                    let group2 = GlyphGroup(tokens: newTokens, generateType: GENERATE_TYPE.SPLIT)
                    ret.append(group2)
                    return ret
                } else if glyphGroup.hasSuffix(ligature) {
                    var newTokens = glyphGroup.copyElements()
                    newTokens.removeLast()
                    let group1 = GlyphGroup(tokens: newTokens, generateType: GENERATE_TYPE.SPLIT)
                    ret.append(group1)
                    let group2 = GlyphGroup(glyphGroup: ligature, generateType: GENERATE_TYPE.SPLIT)
                    ret.append(group2)
                    return ret
                }
            }
        }
        
        if ret.count == 0 {
            ret.append(glyphGroup)
            let rand = randomNumberGenerator.rand(100)
            if rand < 30 && glyphGroup.count > 2  {
                var newTokens = glyphGroup.copyElements()
                newTokens.removeAtIndex(0)
                let group2 = GlyphGroup(tokens: newTokens, generateType: GENERATE_TYPE.SPLIT)
                ret.append(group2)
            }
        }
        
        return ret
    }

    /// try to add a glyph
    func addRandomGlyph(glyphGroup: GlyphGroup, isParagraphInitial: Bool, isLineInitial: Bool) -> GlyphGroup {
        if isParagraphInitial {
            let rand = randomNumberGenerator.rand(100)
            if rand < 80 {
                return addGallow(glyphGroup, isParagraphInitial: isParagraphInitial, isLineInitial: isLineInitial)
            } else {
                return addPrefix(glyphGroup, isLineInitial: isLineInitial )
            }
        } else {
            let rand = randomNumberGenerator.rand(100)
            if rand < 8 {
                return addGallow(glyphGroup, isParagraphInitial: isParagraphInitial, isLineInitial: isLineInitial)
            } else {
                return addPrefix(glyphGroup, isLineInitial: isLineInitial )
            }
        }
    }
    
    /// add a prefix
    func addPrefix(glyphGroup: GlyphGroup, isLineInitial: Bool) -> GlyphGroup {
        for var i = 0; i < 4; i++ {
            let index = randomNumberGenerator.rand(prefixGlyphs.count)
            let prefix = Array(prefixGlyphs.keys)[index]
            if prefix == "q" {
                var doit = true
                // "q" is less frequent for Currier A
                if currierType == CURRIER.A {
                    let rand = randomNumberGenerator.rand(100)
                    if rand > 25 {
                        doit = false
                    }
                }
                if doit {
                    let startToken = glyphGroup[0]
                    //let length = startToken.characters.count
                    if startToken.hasPrefix("o") || startToken.hasPrefix("y") {
                        var newTokens = glyphGroup.copyElements()
                        newTokens[0] = "qo"
                        var generateType = GENERATE_TYPE.ADD
                        if glyphGroup.generateType == GENERATE_TYPE.COMBINE {
                            generateType = glyphGroup.generateType
                        }
                        return GlyphGroup(tokens: newTokens, generateType: generateType)
                    }
                }
            } else if prefix == "x" {
                if currierType != CURRIER.A {
                    let rand = randomNumberGenerator.rand(100)
                    if rand < 30 {
                        let allowed = prefixGlyphs[prefix]
                        if let allowedFirstGlyphs = allowed {
                            for glyph in allowedFirstGlyphs {
                                if glyphGroup.hasPrefix(glyph) {
                                    var newTokens = glyphGroup.copyElements()
                                    newTokens.insert(prefix, atIndex: 0)
                                    var generateType = GENERATE_TYPE.ADD
                                    if glyphGroup.generateType == GENERATE_TYPE.COMBINE {
                                        generateType = glyphGroup.generateType
                                    }
                                    return GlyphGroup(tokens: newTokens, generateType: generateType)
                                }
                            }
                        }
                    }
                }
            } else {
                let allowed = prefixGlyphs[prefix]
                if let allowedFirstGlyphs = allowed {
                    for glyph in allowedFirstGlyphs {
                        if glyphGroup.hasPrefix(glyph) {
                            let length = glyphGroup.count
                            var newTokens = glyphGroup.copyElements()
                            // 'd' and 'ch' can change into a gallow if a prefix is added  (o + daiin --> okaiin || y + chol --> ykol)
                            if length > 2 && (prefix == "o" || prefix == "y" || prefix == "l") && (glyphGroup[0] == "d" || glyphGroup[0] == "ch") {
                                let rand = randomNumberGenerator.rand(100)
                                if rand < 70 {
                                    let gallow = Glyph.randomGallow(firstLine: false, randomNumberGenerator: randomNumberGenerator)
                                    if Glyph.canFollowEachOther(glyphToAdd: gallow, group2: newTokens[1]) {
                                        newTokens[0] = gallow
                                    }
                                }
                            }
                            newTokens.insert(prefix, atIndex: 0)
                            var generateType = GENERATE_TYPE.ADD
                            if glyphGroup.generateType == GENERATE_TYPE.COMBINE {
                                generateType = glyphGroup.generateType
                            }
                            return GlyphGroup(tokens: newTokens, generateType: generateType)
                        }
                    }
                }
            }
        }

        return glyphGroup
    }
    
    /// prefer an lineInitalGlyph [o,y,d,s] to start a line
    func addLineInitalGlyph(glyphGroup: GlyphGroup) -> GlyphGroup {
        if !glyphGroup.startsWithLineInitialGlyph() {
            var rand = randomNumberGenerator.rand(100)
            
            if rand < 30 {
                let length = glyphGroup.count
                let glyph = Glyph.randomLineInitalGlyph(randomNumberGenerator)
                var newTokens = glyphGroup.copyElements()
                // o + daiin --> okaiin / o + chol --> okol
                if length > 2 && (glyph == "o" || glyph == "y") && (glyphGroup[0] == "d" || glyphGroup[0] == "ch") {
                    rand = randomNumberGenerator.rand(100)
                    if rand < 90 {
                        let gallow = Glyph.randomGallow(firstLine: false, randomNumberGenerator: randomNumberGenerator)
                        if Glyph.canFollowEachOther(glyphToAdd: gallow, group2: newTokens[1]) {
                            newTokens[0] = gallow
                        }
                    }
                }
                if Glyph.canFollowToInitalGlyph(glyphToAdd: glyph, group2: newTokens[0]) {
                    newTokens.insert(glyph, atIndex: 0)
                    return GlyphGroup(tokens: newTokens, generateType: glyphGroup.generateType)
                }
            }
        }
        
        return glyphGroup
    }
    
    /// remove an lineInitalGlyph [o,y,d,s]
    func removeLineInitalGlyph(glyphGroup: GlyphGroup) -> GlyphGroup {
        let length = glyphGroup.count
        if glyphGroup.startsWithLineInitialGlyph() && length > 2 {
            var newTokens = glyphGroup.copyElements()
            newTokens.removeAtIndex(0)
            
            let first = newTokens[0]
            let second = newTokens[1]
            if Glyph.isGallow(first) {
                if second.hasPrefix("a") {
                    newTokens[0] = "d"
                }
                if second.hasPrefix("e") {
                    newTokens[0] = "ch"
                }
            }
            
            return GlyphGroup(tokens: newTokens, generateType: glyphGroup.generateType)
        }
        
        return glyphGroup
    }
    
    /// return a group with an additional gallow or the source `glyphGroup`
    func addGallow(glyphGroup: GlyphGroup, isParagraphInitial: Bool, isLineInitial: Bool) -> GlyphGroup {
        let length = glyphGroup.count
        if isParagraphInitial && isLineInitial {
            let gallow = Glyph.randomGallow(firstLine: isParagraphInitial, randomNumberGenerator: randomNumberGenerator)
            var glyphGroup = tryToPlaceGallow(gallow: gallow, glyphGroup: glyphGroup, pos: 0)
            if glyphGroup[0] != gallow {
                var newTokens = glyphGroup.copyElements()
                newTokens[0] = "o"
                newTokens.insert(gallow, atIndex: 0)
                glyphGroup = GlyphGroup(tokens: newTokens, generateType: glyphGroup.generateType)
            }
            
            return glyphGroup
        } else if length > 1 {
            var doit = true
            // multiple gallows are rare
            if glyphGroup.containsGallow() {
                let rand = randomNumberGenerator.rand(100)
                if rand < 90 {
                    doit = false
                }
            }
            if doit {
                for var i = 0; i < 5; i++ {
                    let pos = isParagraphInitial ? randomNumberGenerator.rand(length) : length == 2 ? 1 : (randomNumberGenerator.rand((length-2)) + 1)
                    let gallow = Glyph.randomGallow(firstLine: isParagraphInitial, randomNumberGenerator: randomNumberGenerator)
                    let newGlyphGroup = tryToPlaceGallow(gallow: gallow, glyphGroup: glyphGroup, pos: pos)
                    if newGlyphGroup != glyphGroup {
                        return newGlyphGroup
                    }
                }
            }
        }
        
        return glyphGroup
    }
    
    
    /// tries to add a `gallow` at `pos` and returns the result
    func tryToPlaceGallow(gallow gallow: String, glyphGroup: GlyphGroup, pos: Int) -> GlyphGroup {
        
        let last = pos == 0 ? "" : glyphGroup[pos-1]
        let next = pos == glyphGroup.count ? "" : glyphGroup[pos]
        let lastOk = Glyph.canFollowEachOther(group1: last, glyphToAdd: gallow)
        let nextOk = Glyph.canFollowEachOther(glyphToAdd: gallow, group2: next)
        
        if lastOk && nextOk {
            var newTokens = glyphGroup.copyElements()
            newTokens.insert(gallow, atIndex: pos)
            return GlyphGroup(tokens: newTokens, generateType: glyphGroup.generateType)
        } else {
            var newTokens = glyphGroup.copyElements()
            if lastOk {
                let alternativeSuffix = glyphGroup.count > pos+1 ? glyphGroup[pos+1] : "-"
                if Glyph.canFollowEachOther(glyphToAdd: gallow, group2: alternativeSuffix) {
                    newTokens[pos] = gallow
                    return GlyphGroup(tokens: newTokens, generateType: glyphGroup.generateType)
                } else {
                    return glyphGroup
                }
            } else if nextOk {
                let nextToLastGlyph = pos - 2 > 0 ? glyphGroup[pos-2] : "-"
                if Glyph.canFollowEachOther(group1: nextToLastGlyph, glyphToAdd: gallow){
                    newTokens[pos-1] = gallow
                    return GlyphGroup(tokens: newTokens, generateType: glyphGroup.generateType)
                } else {
                    return glyphGroup
                }
            } else {
                return glyphGroup
            }
        }
    }
    
    /// replace gallow glyphs
    func replaceFirstLineGallows(glyphGroup: GlyphGroup) -> GlyphGroup {
        var newTokens = glyphGroup.copyElements()
        for var i = 0; i < newTokens.count; i++ {
            var token = newTokens[i]
            if Glyph.containsFirstLineGallow(token) {
                let newGallow = Glyph.randomGallow(firstLine: false, randomNumberGenerator: randomNumberGenerator)
                token = Glyph.replaceFirstLineGallow(token, newGallow: newGallow)
                newTokens[i] = token
            }
        }
        return GlyphGroup(tokens: newTokens, generateType: glyphGroup.generateType)
    }
    
    /// replace gallow glyphs
    func replaceWithFirstLineGallows(glyphGroup: GlyphGroup) -> GlyphGroup {
        var newTokens = glyphGroup.copyElements()
        for var i = 0; i < newTokens.count; i++ {
            var token = newTokens[i]
            if Glyph.containsGallow(token) {
                let newGallow = Glyph.randomGallow(firstLine: true, randomNumberGenerator: randomNumberGenerator)
                token = Glyph.replaceGallows(token, newGallow: newGallow)
                newTokens[i] = token
            }
        }
        return GlyphGroup(tokens: newTokens, generateType: glyphGroup.generateType)
    }
}